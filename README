SIMCORE README 

  Authored by JMM on 3/2/2017. If you have any questions, feel free to contact
  me: jeffrey.m.moore@colorado.edu

DISCLAIMER:

  Simcore is in perpetual heavy development. If you run into any bugs or
  crashes, please let me know.

INSTALLATION: 

  For successful installation, make sure you have the following
  libraries/binaries installed:
    - g++-6 
    - yaml-cpp (https://github.com/jbeder/yaml-cpp)
    - openGL
    - gsl
    - glew
    - glfw3
    - openmp
    - (others I may have forgotten)

  The command 'make simcore' will build the simcore binary in the local
  directory in debug mode. You can use the commands 'make CFG=release
  THREADING=eomp simcore' to use optimization flags and enable parallel
  processing using openmp. You also have the option to compile without graphics
  enabled using the NOGRAPH=true option, and you can set the number of cores to
  use for openmp with the environment variable OMP_NUM_THREADS=4.

CONFIGURATION: 

  simcore comes with it's own parameter initialization tool, simcore_config,
  which can be installed by following the above installation instructions for
  simcore and then doing 'make simcore_config'. 
  
  simcore_config makes it easy to add new parameters to the simulation without
  mucking around in the source code. Just add your new parameter to the
  src/master_params.yaml file using the following format:
    
  new_parameter_name: [default_parameter_value, parameter_type]

  Running simcore_config will look at all the parameters in the
  master_params.yaml file and add them seamlessly to the proper simcore files,
  and you can begin using them in your classes right away after recompiling
  simcore. NOTE: for some reason, yaml-cpp is inconsistent about its treatment
  of boolean values. For type-safety reasons, it's best to use integers instead
  of bools when adding flag parameters.

RUNNING SIMCORE:

  The simcore binary is run with

    ./simcore params_file --flag1 option1 --flag2 ...

  The following flags are available:

    --help (-h): show the help menu which gives short descriptions about each of
                 the flags as well as binary usage

    --debug (-d): run the simulation while setting the debug_trace flag, which
                  is a global flag that can be used to output debug info or run
                  unit tests

    --run-name rname (-r rname): overwrites the parameter "run_name" with rname
                                 which serves as a prefix for all outputs 

    --n-runs num (-n num): overwrites the parameter "n_runs" with num, which
                           tells the simulation how many times to run the given
                           parameter set with different random number generator
                           seeds.

    --movie (-m): uses the parameters file params_file to load any output files
                  that were generated from previous runs of the simulation to
                  replay the graphics and record the frames as bitmaps into the
                  directory specified with the "movie_directory" parameter.

    --posit (-p): makes simcore use the position (.posit) files  instead of
                  species (.spec) files to run analyses or make movies. Useful
                  for simple object types (like spheres) that don't require more
                  than position, orientation, length, diameter, etc, or if you
                  don't need fine-grained visualization of more complicated
                  objects.

    --analysis (-a): loads posit/spec files into simulation for analysis in the
                     same manner as the movie flag, however no analysis code is
                     currently written for most objects.

    --load (-l): specifies to load any checkpoint files corresponding to the
                 given parameter file, which can be used to continue a
                 simulation that ended prematurely.

PARAMETERS: 

  There are three types of parameters, but only two are necessary: global and
  species. Global parameters are seen by the entire system and species
  parameters are unique to the specified species. There is also an optional
  "global species" parameter type that affects every species.
  
  The parameter file must be in the YAML file format and is set up in
  the following way:

  global_param_1: gp1_value
  global_param_2: gp2_value
  species: # This is the global species parameter
    global_species_param_1: gsp1_value
    global_species_param_2: gsp2_value
  specific_species_name:
    species_param_1: sp1_value
    species_param_2: sp2_value

  The "global species" parameter type houses parameters that are shared be every
  species, such as "num" which specifies how many items of each species to
  insert into the system, "insertion_type" which specifies how to insert them,
  "posit_flag" which instructs whether to output position files, etc. These do
  not have to be specified using the global species parameter, however, and may
  instead be specified by each specific species.

  If any parameter is not specified in the parameter file, any instance of that
  parameter in the simulation will assume its default value specified in the
  master_params.yaml file.

  Some important global parameters to consider are:

  seed: simulation seed to use with random number generator 
  run_name: prefix for all output files
  n_runs: number of individual runs of each parameter type
  n_random: number of samples from a random parameter space (see more below)
  n_dim: number of dimensions of simulation
  n_periodic: number of periodic dimensions of simulation
  delta: simulation time step
  n_steps: total number of steps in each simulation
  system_radius: "box radius" of system
  graph_flag: run with graphics enabled
  n_graph: how many simulation steps to take between updating graphics
  movie_flag: whether to record the graphics frames into bitmaps
  movie_directory: local directory used to save the recorded bitmaps
  cell_length: linear size of cells used by cell lists (used by interactions)
  n_update_cells: how often to update the cell lists
  f_cutoff: maximum force to apply between pair interactions
  thermo_flag: whether to output thermodynamics outputs (stress tensors, etc)
  n_thermo: how often to output the thermodynamics outputs
  wca_eps/wca_sig/ss_a/ss_rs/ss_eps: potential parameters

  Some important species parameters to consider are:

  num: how many to insert into system
  insertion_type: how to insert object into system (e.g. random)
  overlap: whether species can overlap (should be 0 with interactions)
  draw_type: (orientation or flat) whether to color by orientation or not
  color: a double that specifies the flat rgb value of the object
  posit_flag: whether to output position files
  n_posit: how often to output position files
  spec_flag: whether to output species files
  n_spec: how often to output species files
  checkpoint_flag: whether to output checkpoint files
  n_checkpoint: how often to output checkpoint files

  All parameters used in the simulation and their default values are specified
  in the master_params.yaml file in the src folder.

PARAMETER SETS:

  Using parameter sets, it becomes easier to run many simulations over a given
  parameter space. There are two types of parameter sets possible with simcore:
  defined and random. Each parameter set type works the same with both global
  parameters and species parameters.

DEFINED PARAMETER SETS:
  
  Defined parameter sets are used in this way in the parameter file:

  seed: 4916819461895
  run_name: defined_set
  n_runs: N
  parameter_name1: param_value1
  parameter_name2: [param_value2, param_value3]
  parameter_name3: [param_value4, param_value5]

  Parameters specified in this way (as lists of parameters) will be iterated
  over until every possible combination of parameters has been run. In this
  example, simcore will run N simulations each of the following 4 parameter
  sets:

  seed: random_seed_1
  run_name: defined_set_v000
  n_runs: N
  parameter_name1: param_value1
  parameter_name2: param_value2
  parameter_name3: param_value4

  seed: random_seed_2
  run_name: defined_set_v001
  n_runs: N
  parameter_name1: param_value1
  parameter_name2: param_value2
  parameter_name3: param_value5

  seed: random_seed_3
  run_name: defined_set_v002
  n_runs: N
  parameter_name1: param_value1
  parameter_name2: param_value3
  parameter_name3: param_value4

  seed: random_seed_4
  run_name: defined_set_v003
  n_runs: N
  parameter_name1: param_value1
  parameter_name2: param_value3
  parameter_name3: param_value5

RANDOM PARAMETER SETS:

  Random parameter sets are designed specifically to be used with
  polynomial-chaos theory for n-dimensional parameter spaces for large n. Random
  sets are used in the following way:

  seed: 2546954828254
  n_runs: N
  n_random: M
  parameter_name1: param_value1
  parameter_name2: [R, A, B]     # sets to random real in range (A,B)
  parameter_name3: [RINT, C, D]  # sets to random int in range [C,D]
  parameter_name4: [RLOG, F, G]    # sets to 10^K for rand real K in range (F,G)

  Given this parameter file, simcore will run N simulations each of M random
  parameter sets. The random parameter sets are generated in ranges
  specified in the lists that are prefixed by the R, RINT, RLOG options.

  In this example, the sampled parameter space has dimensionality of n=3, since
  there are only three parameters we are sampling over. Each parameter set will
  have a random real number for parameter_name2 in the the range (A,B), a random
  integer in the range [C,D] for parameter_name3, and will set parameter_name4
  to 10^K for random real number K in the range (F,G). 
  
  Simcore will then run each parameter set N times each with a unique seed, and
  repeat this random process M times. It will therefore take N samples of M
  random points in the n-dimensional parameter space.

INTERACTIONS:
  
  Pair interactions are handled in the InteractionEngine class and use cell
  lists to exclude interactions between distant particles, improving
  performance. Using large objects in simcore requires representing the object
  as a composite of smaller, simple objects (simcore = SIMple Composite
  Object REpresentation). A good example of a large object being decomposed
  into simple objects is done in the Filament and HardRod classes.

POTENTIALS:
  
  Simcore is designed to be able to use interchangable potentials for various
  objects, however this is a feature that is not currently finished (despite it
  being a simple thing to add), mostly because all interactions I have been
  interested in use WCA hard-wall potentials. In the meantime, you will have to
  manually edit the InteractionEngine class in the ProcessInteraction function
  to change the potential you would like to use in your system. For example, the
  current setup is designed to use the hard WCA potential for pair interactions.
  However, it is possible to use other potentials that have been written,
  including a variation of the soft shoulder potential and the Lennard-Jones
  12-6 potential.

  If you are confused about this, let me know.

OUTPUTS:
  
  Simcore has four output types. Three are species specific (posit, spec,
  checkpoint), and the fourth is the statistical information file (thermo). All
  files are binary.

  The posit file has the following header format:

  int n_steps, int n_posit, double delta 

  Followed by n_steps/n_posit lines of data with the format:

  double position[3]
  double scaled_position[3]
  double orientation[3]
  double diameter
  double length

  Where the scaled position is position mapped into the periodic coordinate
  space. The position itself gives the particle trajectory over time independent
  of periodicity.

  The spec file is a custom output file for each species, and can have the same
  information as the posit file or additional information if needed.

  The checkpoint file is almost a copy of the spec file, except it also contains
  the random number generator information and is overwritten every n_checkpoint
  steps in the simulation. It can therefore be used to resume a simulation that
  ended prematurely.

  The thermo file contains the following header information:

  int n_steps, int n_thermo, double delta, int n_dim

  followed by n_steps/n_thermo lines of data in the following format:

  double unit_cell[9]
  double pressure_tensor[9]
  double pressure
  double volume

  Where the pressure is the isometric pressure, and the pressure tensor is
  calculated from the time-averaged stress tensor.

